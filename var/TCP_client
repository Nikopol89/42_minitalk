#include "minitalk.h"

const static char	*g_av;

static void	ft_eot(int pid)
{
	t_byte	op;

	op = 128;
	while (op)
	{
		usleep(SHORT);
		kill(pid, SIGUSR1);
		op >>= 1;
	}
}

static void	ft_encode(const char *str, int pid)
{
	static t_byte	op;
	int				sig;
	static int		i;
	static int		flag;

	if (flag)
	{
		ft_printf("ACK signal from %d received. Bye!\n", pid);
		exit (0);
	}
	if (str[i])
	{
		op = 128;
		while (op)
		{
			usleep(SHORT);
			if (str[i] & op)
				sig = SIGUSR1;
			else
				sig = SIGUSR2;
			op >>= 1;
			kill(pid, sig);
		}
		i++;
	}
	else
	{
		flag++;
		ft_eot(pid);
	}
}

static void ft_runtime_ack(int sig, siginfo_t *info, void *ucontext)
{
	(void)ucontext;
	if (sig == SIGUSR1)
		ft_encode(g_av, info->si_pid);
	if (sig == SIGUSR2)
	{
		ft_printf("Error signal from %d :(\n", info->si_pid);
		exit (0);
	}
}

static void	ft_init_signals(
	struct sigaction act_usr1, struct sigaction	act_usr2)
{
	act_usr1.sa_sigaction = &ft_runtime_ack;
	act_usr2.sa_sigaction = &ft_runtime_ack;
	act_usr1.sa_flags = SA_SIGINFO;
	act_usr2.sa_flags = SA_SIGINFO;
	sigemptyset(&act_usr1.sa_mask);
	sigemptyset(&act_usr2.sa_mask);
	sigaddset(&act_usr1.sa_mask, SIGUSR2);
	sigaddset(&act_usr2.sa_mask, SIGUSR1);
	sigaction(SIGUSR1, &act_usr1, NULL);
	sigaction(SIGUSR2, &act_usr2, NULL);
}

int	main(int argc, char **argv)
{
	struct sigaction	act_usr1;
	struct sigaction	act_usr2;
	int					pid;

	if (argc != 3)
	{
		ft_printf("Error\n");
		return (0);
	}
	pid = ft_atoi(argv[1]);
	g_av = argv[2];
	ft_init_signals(act_usr1, act_usr2);
	ft_printf("%d sending to %d . . .\n", getpid(), pid);
	ft_printf("Standby for ACK . . .\n");
	ft_encode(argv[2], pid);
	while (1)
	{
	}
	return (0);
}
